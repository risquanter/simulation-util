name: CI Build + Sigstore provenance

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

permissions:
  contents: read
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      - name: Install tools
        run: sudo apt-get update -y && sudo apt-get install -y jq tar gpg xmlstarlet zip


      - name: Import encrypted GPG private-subkey into ephemeral GNUPGHOME
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail

          # create ephemeral GNUPGHOME for isolation
          export GNUPGHOME="$(mktemp -d)"
          chmod 700 "$GNUPGHOME"

          # write the armored encrypted blob to a temp file (do not expose to logs)
          TMP_ENC="/tmp/private-subkey.asc.gpg"
          printf '%s' "$GPG_PRIVATE_KEY" > "$TMP_ENC"
          chmod 600 "$TMP_ENC"

          # decrypt the encrypted blob into a temporary plaintext file
          TMP_PLAINT="/tmp/private-subkey.asc"
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
            --decrypt --output "$TMP_PLAINT" "$TMP_ENC"

          # import the plaintext secret subkey into the ephemeral GNUPGHOME
          gpg --batch --import "$TMP_PLAINT"

          # kill agent to ensure allowed settings are applied later if needed
          gpgconf --kill gpg-agent || true

          # discover the signing keyid (first secret key)
          KEYID=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5; exit}')
          if [ -z "$KEYID" ]; then
            echo "Failed to determine GPG KEYID"
            shred -u "$TMP_PLAINT" || rm -f "$TMP_PLAINT"
            rm -f "$TMP_ENC"
            exit 1
          fi

          # export GNUPGHOME and KEYID for subsequent steps
          echo "GNUPGHOME=$GNUPGHOME" >> $GITHUB_ENV
          echo "GPG_KEYID=$KEYID" >> $GITHUB_ENV

          # store public key copy for inspection if needed
          gpg --armor --export "$KEYID" > "$GNUPGHOME/publickey.asc"

          # securely delete the plaintext file as soon as possible
          shred -u "$TMP_PLAINT" || rm -f "$TMP_PLAINT"
          rm -f "$TMP_ENC"

          echo "Imported encrypted GPG subkey into ephemeral GNUPGHOME and removed plaintext."



      - name: Build and run tests
        run: mvn -B -ntp clean verify -Dgpg.passphrase="${{ secrets.GPG_PASSPHRASE }}"

      - name: Create Maven deployment bundle
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail

          # Extract version from POM
          VERSION=$(xmlstarlet sel -t -v "/_:project/_:version" pom.xml)
          echo "Detected version: $VERSION"

          # Sign POM file manually (maven-gpg-plugin doesn't do this automatically)
          # Temporarily commented out to test if GPG plugin handles POM signing
          # gpg --batch --yes --pinentry-mode loopback \
          #   --passphrase "${GPG_PASSPHRASE}" \
          #   --armor --detach-sign pom.xml

          # Create Maven repository structure
          BUNDLE_DIR="maven_bundle"
          mkdir -p "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION"

          # Copy artifacts with GPG signatures
          cp target/simulation.util-$VERSION.jar "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION.jar.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-sources.jar "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-sources.jar.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-javadoc.jar "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-javadoc.jar.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"

          # Copy Sigstore JSON files
          cp target/simulation.util-$VERSION.jar.sigstore.json "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-sources.jar.sigstore.json "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-javadoc.jar.sigstore.json "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"

          # Copy POM and signature with proper naming
          cp pom.xml "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/simulation.util-$VERSION.pom"
          # Copy POM signature if it exists (manual signing)
          if [[ -f pom.xml.asc ]]; then
            cp pom.xml.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/simulation.util-$VERSION.pom.asc"
          fi
          # Copy POM signature if it exists (plugin signing)
          if [[ -f target/simulation.util-$VERSION.pom.asc ]]; then
            cp target/simulation.util-$VERSION.pom.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/simulation.util-$VERSION.pom.asc"
          fi

          # Copy POM sigstore file if it exists
          if [[ -f target/simulation.util-$VERSION.pom.sigstore.json ]]; then
            cp target/simulation.util-$VERSION.pom.sigstore.json "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          fi

          # Generate checksums for Maven Central
          cd "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION"
          for file in simulation.util-$VERSION.jar simulation.util-$VERSION-sources.jar simulation.util-$VERSION-javadoc.jar simulation.util-$VERSION.pom; do
            md5sum "$file" | awk '{print $1}' > "$file.md5"
            sha1sum "$file" | awk '{print $1}' > "$file.sha1"
          done
          cd -

          # Create deployment bundle ZIP
          cd "$BUNDLE_DIR"
          zip -r "../maven-central-artifacts.zip" .
          cd ..

          # Also create simple artifacts for Sigstore signing
          mkdir -p out
          cp target/simulation.util-*.jar out/
          cp pom.xml out/
          cd out
          sha256sum *.jar pom.xml > checksums.sha256

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.3.0

      - name: Sign artifacts with Sigstore
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          # Sign each artifact and generate provenance
          cd out
          for file in *.jar; do
            # Generate signature file with certificate bundle
            cosign sign-blob --yes --bundle "${file}.bundle" "$file"
            # Extract signature and certificate
            jq -r '.Sig' "${file}.bundle" > "${file}.sig"
            jq -r '.Cert' "${file}.bundle" > "${file}.cert"

            # Generate SLSA provenance with blob signing (attestation)
            echo '{"buildType": "https://github.com/actions/runner","builder": {"id": "GitHub Actions"}}' | \
            cosign sign-blob --yes --bundle "${file}.attest.bundle" -
          done

          # --- CHANGED: also sign pom.xml with Sigstore and produce pom.xml.bundle / pom.xml.sig / pom.xml.cert
          # Sign pom.xml and generate bundle + extracted sig/cert
          cosign sign-blob --yes --bundle "pom.xml.bundle" "pom.xml"
          jq -r '.Sig' "pom.xml.bundle" > "pom.xml.sig"
          jq -r '.Cert' "pom.xml.bundle" > "pom.xml.cert"
          # Optionally produce an attest bundle for the pom as well
          echo '{"buildType": "https://github.com/actions/runner","builder": {"id": "GitHub Actions"}}' | \
            cosign sign-blob --yes --bundle "pom.xml.attest.bundle" -

          # Package provenance files (include pom-related provenance)
          tar czf provenance.tgz *.sig *.cert *.bundle

      - name: Upload Maven deployment bundle
        uses: actions/upload-artifact@v4
        with:
          name: deployment-${{ github.run_id }}
          path: maven-central-artifacts.zip
          retention-days: 7

      - name: Upload provenance
        uses: actions/upload-artifact@v4
        with:
          name: provenance-${{ github.run_id }}
          path: out/provenance.tgz
          retention-days: 7

      - name: Cleanup GPG
        if: always()
        run: |
          if [ -n "${GNUPGHOME:-}" ] && [ -d "${GNUPGHOME}" ]; then
            rm -rf "${GNUPGHOME}"
          fi
