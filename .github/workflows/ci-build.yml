name: CI Build + Sigstore provenance

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

permissions:
  contents: read
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      - name: Install tools
        run: sudo apt-get update -y && sudo apt-get install -y jq tar gpg xmlstarlet zip


      - name: Import GPG key for signing
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          export GNUPGHOME="$(mktemp -d)"
          chmod 700 "$GNUPGHOME"

          echo "$GPG_PRIVATE_KEY" | gpg --batch --import

          KEYID=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5; exit}')
          echo "GNUPGHOME=$GNUPGHOME" >> $GITHUB_ENV
          echo "GPG_KEYID=$KEYID" >> $GITHUB_ENV



      - name: Build and run tests
        run: mvn -B -ntp clean verify -Dgpg.passphrase="${{ secrets.GPG_PASSPHRASE }}"

      - name: Create Maven deployment bundle
        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail

          # Extract version from POM
          VERSION=$(xmlstarlet sel -t -v "/_:project/_:version" pom.xml)
          echo "Detected version: $VERSION"

          # Sign POM file manually (maven-gpg-plugin doesn't do this automatically)
          gpg --batch --yes --pinentry-mode loopback \
            --passphrase "${GPG_PASSPHRASE}" \
            --armor --detach-sign pom.xml

          # Create Maven repository structure
          BUNDLE_DIR="maven_bundle"
          mkdir -p "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION"

          # Copy artifacts with GPG signatures
          cp target/simulation.util-$VERSION.jar "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION.jar.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-sources.jar "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-sources.jar.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-javadoc.jar "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-javadoc.jar.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"

          # Copy POM and signature with proper naming
          cp pom.xml "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/simulation.util-$VERSION.pom"
          cp pom.xml.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/simulation.util-$VERSION.pom.asc"

          # Generate checksums for Maven Central
          cd "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION"
          for file in simulation.util-$VERSION.jar simulation.util-$VERSION-sources.jar simulation.util-$VERSION-javadoc.jar simulation.util-$VERSION.pom; do
            md5sum "$file" | awk '{print $1}' > "$file.md5"
            sha1sum "$file" | awk '{print $1}' > "$file.sha1"
          done
          cd -

          # Create deployment bundle ZIP
          cd "$BUNDLE_DIR"
          zip -r "../maven-central-artifacts.zip" .
          cd ..

          # Also create simple artifacts for Sigstore signing
          mkdir -p out
          cp target/simulation.util-*.jar out/
          cp pom.xml out/
          cd out
          sha256sum *.jar pom.xml > checksums.sha256

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.3.0

      - name: Sign artifacts with Sigstore
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          # Sign each artifact and generate provenance
          cd out
          for file in *.jar; do
            # Generate signature file with certificate bundle
            cosign sign-blob --yes --bundle "${file}.bundle" "$file"
            # Extract signature and certificate
            jq -r '.Sig' "${file}.bundle" > "${file}.sig"
            jq -r '.Cert' "${file}.bundle" > "${file}.cert"

            # Generate SLSA provenance with blob signing (attestation)
            echo '{"buildType": "https://github.com/actions/runner","builder": {"id": "GitHub Actions"}}' | \
            cosign sign-blob --yes --bundle "${file}.attest.bundle" -
          done

          # --- CHANGED: also sign pom.xml with Sigstore and produce pom.xml.bundle / pom.xml.sig / pom.xml.cert
          # Sign pom.xml and generate bundle + extracted sig/cert
          cosign sign-blob --yes --bundle "pom.xml.bundle" "pom.xml"
          jq -r '.Sig' "pom.xml.bundle" > "pom.xml.sig"
          jq -r '.Cert' "pom.xml.bundle" > "pom.xml.cert"
          # Optionally produce an attest bundle for the pom as well
          echo '{"buildType": "https://github.com/actions/runner","builder": {"id": "GitHub Actions"}}' | \
            cosign sign-blob --yes --bundle "pom.xml.attest.bundle" -

          # Package provenance files (include pom-related provenance)
          tar czf provenance.tgz *.sig *.cert *.bundle

      - name: Upload Maven deployment bundle
        uses: actions/upload-artifact@v4
        with:
          name: bundle-${{ github.run_id }}
          path: maven-central-artifacts.zip
          retention-days: 7

      - name: Upload provenance
        uses: actions/upload-artifact@v4
        with:
          name: provenance-${{ github.run_id }}
          path: out/provenance.tgz
          retention-days: 7

      - name: Cleanup GPG
        if: always()
        run: |
          if [ -n "${GNUPGHOME:-}" ] && [ -d "${GNUPGHOME}" ]; then
            rm -rf "${GNUPGHOME}"
          fi
