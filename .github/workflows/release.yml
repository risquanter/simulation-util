###############################################################
# This workflow is adapted for Maven Central Publisher Portal
# Migration from OSSRH: all endpoints, authentication, and deployment
# now use the Central Publisher Portal API and token-based auth.
#
# Required repository secrets:
#   - GPG_PRIVATE_KEY: ASCII-armored GPG private key for signing
#   - GPG_PASSPHRASE: Passphrase for the GPG key
#   - TOTP_SECRET: Base32 secret for TOTP verification
#   - CENTRAL_PORTAL_USERNAME: Username (special purpose) for Maven Central Publisher Portal
#   - CENTRAL_PORTAL_TOKEN: Token generated from Maven Central Publisher Portal
#
# For details, see:
#   https://central.sonatype.org/publish/publish-portal-maven/
#   https://central.sonatype.org/publish/generate-portal-token/
###############################################################

name: Release (Maven Central Publisher Portal, GPG-signed)

on:
  workflow_dispatch:
    inputs:
      run_id:
        description: 'Build run ID to release'
        required: true
      totp_code:
        description: 'TOTP code from your authenticator app'
        required: true

permissions:
  contents: write
  id-token: write

jobs:
  verify-authorization:
    runs-on: ubuntu-latest
    steps:
      - name: Install oathtool
        run: sudo apt-get update && sudo apt-get install --no-install-recommends -y oathtool

      - name: Verify TOTP
        env:
          TOTP_SECRET: ${{ secrets.TOTP_SECRET }}
          INPUT_TOTP: ${{ inputs.totp_code }}
        run: |
          set -euo pipefail
          date --utc
          EXPECTED=$(oathtool --totp --base32 --time-step-size 60 "$TOTP_SECRET")
          if [ "${INPUT_TOTP}" != "$EXPECTED" ]; then
            echo "❌ Invalid TOTP code"
            echo "Expected: $EXPECTED"
            exit 1
          fi
          echo "✅ TOTP verified successfully"


  # JOB 2: Signing and release (ubuntu-latest)
  sign-and-publish:
    needs: verify-authorization
    runs-on: ubuntu-latest
    environment: release
    permissions:
      contents: write
      id-token: write
      actions: read

    env:
      ARTIFACT_RUN_ID: ${{ inputs.run_id }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Install tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq tar gpg xmlstarlet

      - name: Download unsigned artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh run download ${{ inputs.run_id }} \
            --name unsigned-artifacts-${{ inputs.run_id }} \
            --dir /tmp/release-artifacts \
            --repo ${{ github.repository }}

      - name: Download provenance
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh run download ${{ inputs.run_id }} \
            --name provenance-${{ inputs.run_id }} \
            --dir /tmp/release-provenance \
            --repo ${{ github.repository }}

      - name: Extract and verify
        run: |
          set -euo pipefail
          mkdir -p /tmp/artifacts
          tar xzf /tmp/release-artifacts/artifacts.tgz -C /tmp/artifacts
          if [ -f /tmp/release-provenance/provenance.tgz ]; then
            tar xzf /tmp/release-provenance/provenance.tgz -C /tmp/artifacts || true
          fi
          cd /tmp/artifacts
          sha256sum -c checksums.sha256


    # No verification of Sigstore provenance is done here;
    # users can verify signatures after download.
    # Sigstore provenance is attached during deployment below.
      - name: (Optional) List Sigstore provenance files
        run: |
          shopt -s nullglob
          echo "Sigstore provenance files:"
          ls -lh /tmp/artifacts/*.bundle 2>/dev/null || echo "No .bundle files found"
          echo "Sigstore signature files:"
          ls -lh /tmp/artifacts/*.sig 2>/dev/null || echo "No .sig files found"
          echo "Sigstore certificate files:"
          ls -lh /tmp/artifacts/*.cert 2>/dev/null || echo "No .cert files found"

      - name: Import encrypted GPG private-subkey into ephemeral GNUPGHOME
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail

          # create ephemeral GNUPGHOME for isolation
          export GNUPGHOME="$(mktemp -d)"
          chmod 700 "$GNUPGHOME"

          # write the armored encrypted blob to a temp file (do not expose to logs)
          TMP_ENC="/tmp/private-subkey.asc.gpg"
          printf '%s' "$GPG_PRIVATE_KEY" > "$TMP_ENC"
          chmod 600 "$TMP_ENC"

          # decrypt the encrypted blob into a temporary plaintext file
          TMP_PLAINT="/tmp/private-subkey.asc"
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
            --decrypt --output "$TMP_PLAINT" "$TMP_ENC"

          # import the plaintext secret subkey into the ephemeral GNUPGHOME
          gpg --batch --import "$TMP_PLAINT"

          # kill agent to ensure allowed settings are applied later if needed
          gpgconf --kill gpg-agent || true

          # discover the signing keyid (first secret key)
          KEYID=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5; exit}')
          if [ -z "$KEYID" ]; then
            echo "Failed to determine GPG KEYID"
            shred -u "$TMP_PLAINT" || rm -f "$TMP_PLAINT"
            rm -f "$TMP_ENC"
            exit 1
          fi

          # export GNUPGHOME and KEYID for subsequent steps
          echo "GNUPGHOME=$GNUPGHOME" >> $GITHUB_ENV
          echo "GPG_KEYID=$KEYID" >> $GITHUB_ENV

          # store public key copy for inspection if needed
          gpg --armor --export "$KEYID" > "$GNUPGHOME/publickey.asc"

          # securely delete the plaintext file as soon as possible
          shred -u "$TMP_PLAINT" || rm -f "$TMP_PLAINT"
          rm -f "$TMP_ENC"

          echo "Imported encrypted GPG subkey into ephemeral GNUPGHOME and removed plaintext."




      # Write settings.xml for Central Publisher Portal
      # Uses CENTRAL_PORTAL_USERNAME and CENTRAL_PORTAL_TOKEN for authentication
      # Paste the generated <server> block from the portal as shown below
      - name: Write settings.xml for Central Publisher Portal
        env:
          CENTRAL_PORTAL_USERNAME: ${{ secrets.CENTRAL_PORTAL_USERNAME }}
          CENTRAL_PORTAL_TOKEN: ${{ secrets.CENTRAL_PORTAL_TOKEN }}
        run: |
          mkdir -p "$HOME/.m2"
          cat > "$HOME/.m2/settings.xml" << 'EOF'
          <settings xmlns="http://maven.apache.org/SETTINGS/1.0.0">
            <servers>
              <server>
                <id>central</id>
                <username>USERNAME_PLACEHOLDER</username>
                <password>PASSWORD_PLACEHOLDER</password>
              </server>
            </servers>
          </settings>
          EOF

          # Replace placeholders with actual values
          sed -i "s/USERNAME_PLACEHOLDER/${CENTRAL_PORTAL_USERNAME}/g" "$HOME/.m2/settings.xml"
          sed -i "s/PASSWORD_PLACEHOLDER/${CENTRAL_PORTAL_TOKEN}/g" "$HOME/.m2/settings.xml"
          chmod 600 "$HOME/.m2/settings.xml"

          # Verify
          echo "======================================"
          echo "Settings.xml verification:"
          echo "======================================"
          if [ -f "$HOME/.m2/settings.xml" ]; then
            echo "✅ settings.xml exists at: $HOME/.m2/settings.xml"
            echo "File size: $(stat -c%s "$HOME/.m2/settings.xml")"
            echo "Server ID check:"
            grep -q '<id>central</id>' "$HOME/.m2/settings.xml" && echo "✅ Server 'central' configured" || echo "❌ Server 'central' NOT found"
          else
            echo "❌ ERROR: settings.xml was not created!"
            exit 1
          fi
          echo "======================================"

      - name: Log Maven settings
        run: |
          echo "======================================"
          echo "Maven settings debug:"
          echo "======================================"
          echo "HOME: $HOME"
          echo "Contents of $HOME/.m2/settings.xml:"
          cat "$HOME/.m2/settings.xml"
          echo ""
          echo "Running mvn help:effective-settings to see what Maven sees:"
          mvn help:effective-settings -s "$HOME/.m2/settings.xml"

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      - name: Prepare provenance for verification
        run: |
          mkdir -p provenance-${{ inputs.run_id }}
          cp /tmp/artifacts/*.attest.bundle provenance-${{ inputs.run_id }}/

      - name: Install cosign
        uses: sigstore/cosign-installer@v3.3.0

      - name: Deploy to Maven Central Publisher Portal
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
          GPG_KEYID: ${{ env.GPG_KEYID }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          CENTRAL_PORTAL_USERNAME: ${{ secrets.CENTRAL_PORTAL_USERNAME }}
          CENTRAL_PORTAL_TOKEN: ${{ secrets.CENTRAL_PORTAL_TOKEN }}
        run: |
          set -euo pipefail

          # Extract version from POM
          VERSION=$(xmlstarlet sel -t -v "/_:project/_:version" pom.xml)
          echo "Detected version: $VERSION"

          # Configure GPG agent for Maven's GPG plugin
          cat > "$GNUPGHOME/gpg-agent.conf" << EOF
          allow-loopback-pinentry
          max-cache-ttl 7200
          default-cache-ttl 7200
          EOF

          cat > "$GNUPGHOME/gpg.conf" << EOF
          use-agent
          pinentry-mode loopback
          EOF

          # Restart GPG agent with new config
          gpgconf --kill gpg-agent || true
          gpg-agent --daemon --allow-loopback-pinentry || true

          echo "Running Maven build and sign..."

          # Build and sign artifacts only (no deployment via plugin)
          mvn -B -ntp clean verify -DskipTests \
            -Dgpg.passphrase="${GPG_PASSPHRASE}"

          # Manually sign the POM file after build (maven-gpg-plugin doesn't do this automatically)
          echo "Signing POM file..."
          gpg --batch --yes --pinentry-mode loopback \
            --passphrase "${GPG_PASSPHRASE}" \
            --armor --detach-sign pom.xml

          echo "=== Verifying Attestation for JAR ==="
          cosign verify-blob \
            --certificate-identity-regexp="https://github.com/risquanter/simulation-util/.github/workflows/ci-build.yml@refs/heads/main" \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
            --bundle provenance-${{ inputs.run_id }}/simulation.util-$VERSION.jar.attest.bundle \
            target/simulation.util-$VERSION.jar

          echo "=== Verifying Attestation for Sources ==="
          cosign verify-blob \
            --certificate-identity-regexp="https://github.com/risquanter/simulation-util/.github/workflows/ci-build.yml@refs/heads/main" \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
            --bundle provenance-${{ inputs.run_id }}/simulation.util-$VERSION-sources.jar.attest.bundle \
            target/simulation.util-$VERSION-sources.jar

          echo "=== Verifying Attestation for JavaDoc ==="
          cosign verify-blob \
            --certificate-identity-regexp="https://github.com/risquanter/simulation-util/.github/workflows/ci-build.yml@refs/heads/main" \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
            --bundle provenance-${{ inputs.run_id }}/simulation.util-$VERSION-javadoc.jar.attest.bundle \
            target/simulation.util-$VERSION-javadoc.jar

          echo "=== Verifying Attestation for POM ==="
          cosign verify-blob \
            --certificate-identity-regexp="https://github.com/risquanter/simulation-util/.github/workflows/ci-build.yml@refs/heads/main" \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
            --bundle provenance-${{ inputs.run_id }}/pom.xml.attest.bundle \
            pom.xml

          # Create deployment bundle for Maven Central
          echo "Creating deployment bundle with Maven repository layout..."
          BUNDLE_NAME="bundle.zip"
          BUNDLE_DIR="bundle_staging"

          # Extract version from POM
          VERSION=$(xmlstarlet sel -t -v "/_:project/_:version" pom.xml)
          echo "Detected version: $VERSION"

          # Create the Maven repository structure
          mkdir -p "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION"

          # Copy all artifacts to the proper directory structure
          cp target/simulation.util-$VERSION.jar "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION.jar.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-sources.jar "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-sources.jar.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-javadoc.jar "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"
          cp target/simulation.util-$VERSION-javadoc.jar.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/"

          # Copy POM and its signature with proper naming
          cp pom.xml "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/simulation.util-$VERSION.pom"
          cp pom.xml.asc "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION/simulation.util-$VERSION.pom.asc"

          # Generate MD5 and SHA1 checksums for all artifacts
          echo "Generating checksums..."
          cd "$BUNDLE_DIR/com/risquanter/simulation.util/$VERSION"

          for file in simulation.util-$VERSION.jar simulation.util-$VERSION-sources.jar simulation.util-$VERSION-javadoc.jar simulation.util-$VERSION.pom; do
            md5sum "$file" | awk '{print $1}' > "$file.md5"
            sha1sum "$file" | awk '{print $1}' > "$file.sha1"
          done

          cd -

          # Create the ZIP bundle from the staging directory
          cd "$BUNDLE_DIR"
          zip -r "../target/$BUNDLE_NAME" .
          cd ..

          echo "Bundle created: target/$BUNDLE_NAME"
          echo "Bundle structure:"
          unzip -l target/"$BUNDLE_NAME"

          # Clean up staging directory
          rm -rf "$BUNDLE_DIR"

          # Upload to Central Portal using REST API
          echo "Uploading to Central Portal..."

          # Calculate Bearer token: base64 encode username:password
          BEARER_TOKEN=$(printf "%s:%s" "${CENTRAL_PORTAL_USERNAME}" "${CENTRAL_PORTAL_TOKEN}" | base64 -w 0)

          UPLOAD_RESPONSE=$(curl -X POST \
            -H "Authorization: Bearer ${BEARER_TOKEN}" \
            -F "bundle=@target/$BUNDLE_NAME" \
            "https://central.sonatype.com/api/v1/publisher/upload?name=simulation.util-${VERSION}&publishingType=USER_MANAGED")

          echo "Upload response: $UPLOAD_RESPONSE"

          # The response is the deployment ID directly (not JSON)
          DEPLOYMENT_ID=$(echo "$UPLOAD_RESPONSE" | tr -d '[:space:]')
          echo "Deployment ID: $DEPLOYMENT_ID"

          if [ -z "$DEPLOYMENT_ID" ]; then
            echo "❌ Failed to get deployment ID"
            echo "Full response: $UPLOAD_RESPONSE"
            exit 1
          fi

          # Check deployment status
          echo "Checking deployment status..."
          STATUS_RESPONSE=$(
          curl -X POST "https://central.sonatype.com/api/v1/publisher/status?id=$DEPLOYMENT_ID" \
            -H "Authorization: Bearer ${BEARER_TOKEN}" -H "Content-Type: application/json"
            )

          echo "Deployment status: $STATUS_RESPONSE"          # Note: The publish goal stages the deployment
          # You must manually publish from https://central.sonatype.com/

          echo "Deployment completed (staged)."
          echo "Open https://central.sonatype.com/ to inspect and publish the deployment."



      - name: Create signed git tag (GPG)
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
          GPG_KEYID: ${{ env.GPG_KEYID }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Configure git for tagging and authentication
          git config --global user.email "ci@risquanter.example"
          git config --global user.name "Release Bot"
          git config --global url."https://${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"

          # Extract version from POM
          VERSION=$(xmlstarlet sel -t -v "/_:project/_:version" pom.xml)

          # Pre-authenticate GPG agent by signing a dummy file
          echo "test" | gpg --batch --yes --pinentry-mode loopback \
            --passphrase "${GPG_PASSPHRASE}" --local-user "${GPG_KEYID}" \
            --sign --armor > /dev/null 2>&1

          # Create a GPG-signed tag with the version
          git tag -s "v$VERSION" -m "Release v$VERSION" --local-user "$GPG_KEYID" || true

          # Push the tag using authenticated git
          git push origin "v$VERSION"

      - name: Clean up (always)
        if: always()
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
        run: |
          set +e
          # remove ephemeral GNUPGHOME
          if [ -n "${GNUPGHOME:-}" ] && [ -d "${GNUPGHOME}" ]; then
            rm -rf "${GNUPGHOME}"
          fi
          # remove temporary maven settings
          if [ -f "$HOME/.m2/settings.xml" ]; then
            shred -u "$HOME/.m2/settings.xml" || rm -f "$HOME/.m2/settings.xml"
          fi
