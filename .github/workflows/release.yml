###############################################################
# This workflow is adapted for Maven Central Publisher Portal
# Migration from OSSRH: all endpoints, authentication, and deployment
# now use the Central Publisher Portal API and token-based auth.
#
# Required repository secrets:
#   - GPG_PRIVATE_KEY: ASCII-armored GPG private key for signing
#   - GPG_PASSPHRASE: Passphrase for the GPG key
#   - TOTP_SECRET: Base32 secret for TOTP verification
#   - CENTRAL_PORTAL_USERNAME: Username (special purpose) for Maven Central Publisher Portal
#   - CENTRAL_PORTAL_TOKEN: Token generated from Maven Central Publisher Portal
#
# For details, see:
#   https://central.sonatype.org/publish/publish-portal-maven/
#   https://central.sonatype.org/publish/generate-portal-token/
###############################################################

name: Release (Maven Central Publisher Portal, GPG-signed)

on:
  workflow_dispatch:
    inputs:
      run_id:
        description: 'Build run ID to release'
        required: true
      totp_code:
        description: 'TOTP code from your authenticator app'
        required: true

permissions:
  contents: write
  id-token: write

jobs:
  verify-authorization:
    runs-on: ubuntu-latest
    steps:
      - name: Install oathtool
        run: sudo apt-get update && sudo apt-get install --no-install-recommends -y oathtool

      - name: Verify TOTP
        env:
          TOTP_SECRET: ${{ secrets.TOTP_SECRET }}
          INPUT_TOTP: ${{ inputs.totp_code }}
        run: |
          set -euo pipefail
          date --utc
          EXPECTED=$(oathtool --totp --base32 --time-step-size 60 "$TOTP_SECRET")
          if [ "${INPUT_TOTP}" != "$EXPECTED" ]; then
            echo "❌ Invalid TOTP code"
            echo "Expected: $EXPECTED"
            exit 1
          fi
          echo "✅ TOTP verified successfully"


  # JOB 2: Signing and release (ubuntu-latest)
  sign-and-publish:
    needs: verify-authorization
    runs-on: ubuntu-latest
    environment: release

    env:
      ARTIFACT_RUN_ID: ${{ inputs.run_id }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Install tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq tar gpg xmlstarlet

      - name: Download unsigned artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh run download ${{ inputs.run_id }} \
            --name unsigned-artifacts-${{ inputs.run_id }} \
            --dir /tmp/release-artifacts \
            --repo ${{ github.repository }}

      - name: Download provenance
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh run download ${{ inputs.run_id }} \
            --name provenance-${{ inputs.run_id }} \
            --dir /tmp/release-provenance \
            --repo ${{ github.repository }}

      - name: Extract and verify
        run: |
          mkdir -p /tmp/artifacts
          tar xzf /tmp/release-artifacts/artifacts.tgz -C /tmp/artifacts
          if [ -f /tmp/release-provenance/provenance.tgz ]; then
            tar xzf /tmp/release-provenance/provenance.tgz -C /tmp/artifacts || true
          fi
          cd /tmp/artifacts
          sha256sum -c checksums.sha256

      - name: (Optional) Verify Sigstore provenance presence
        run: |
          for s in /tmp/artifacts/*.bundle /tmp/artifacts/*.sigstore.json; do
            [ -f "$s" ] && echo "Found provenance: $s"
          done

      - name: Import encrypted GPG private-subkey into ephemeral GNUPGHOME
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail

          # create ephemeral GNUPGHOME for isolation
          export GNUPGHOME="$(mktemp -d)"
          chmod 700 "$GNUPGHOME"

          # write the armored encrypted blob to a temp file (do not expose to logs)
          TMP_ENC="/tmp/private-subkey.asc.gpg"
          printf '%s' "$GPG_PRIVATE_KEY" > "$TMP_ENC"
          chmod 600 "$TMP_ENC"

          # decrypt the encrypted blob into a temporary plaintext file
          TMP_PLAINT="/tmp/private-subkey.asc"
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
            --decrypt --output "$TMP_PLAINT" "$TMP_ENC"

          # import the plaintext secret subkey into the ephemeral GNUPGHOME
          gpg --batch --import "$TMP_PLAINT"

          # kill agent to ensure allowed settings are applied later if needed
          gpgconf --kill gpg-agent || true

          # discover the signing keyid (first secret key)
          KEYID=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5; exit}')
          if [ -z "$KEYID" ]; then
            echo "Failed to determine GPG KEYID"
            shred -u "$TMP_PLAINT" || rm -f "$TMP_PLAINT"
            rm -f "$TMP_ENC"
            exit 1
          fi

          # export GNUPGHOME and KEYID for subsequent steps
          echo "GNUPGHOME=$GNUPGHOME" >> $GITHUB_ENV
          echo "GPG_KEYID=$KEYID" >> $GITHUB_ENV

          # store public key copy for inspection if needed
          gpg --armor --export "$KEYID" > "$GNUPGHOME/publickey.asc"

          # securely delete the plaintext file as soon as possible
          shred -u "$TMP_PLAINT" || rm -f "$TMP_PLAINT"
          rm -f "$TMP_ENC"

          echo "Imported encrypted GPG subkey into ephemeral GNUPGHOME and removed plaintext."


      - name: Sign artifacts and POM non-interactively with GPG key from secrets
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
          GPG_KEYID: ${{ env.GPG_KEYID }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail
          cd /tmp/artifacts

          # Use loopback pinentry to supply passphrase non-interactively
          for a in *.jar; do
            echo "Signing $a with GPG key $GPG_KEYID..."
            gpg --batch --yes --pinentry-mode loopback --passphrase "${GPG_PASSPHRASE}" \
              --local-user "${GPG_KEYID}" --detach-sign --armor --output "${a}.asc" "$a"

            # Metadata to help auditing which key/runner produced the signature
            echo "Signature created by key: ${GPG_KEYID}" > "${a}.keyinfo"
            echo "Timestamp: $(date -u)" >> "${a}.keyinfo"
            echo "Workflow: $GITHUB_WORKFLOW" >> "${a}.keyinfo"
            echo "Run ID: $GITHUB_RUN_ID" >> "${a}.keyinfo"
          done

          # Sign POM so Sonatype receives pom.xml.asc
          if [ -f pom.xml ]; then
            echo "Signing pom.xml with GPG key $GPG_KEYID..."
            gpg --batch --yes --pinentry-mode loopback --passphrase "${GPG_PASSPHRASE}" \
              --local-user "${GPG_KEYID}" --detach-sign --armor --output "pom.xml.asc" pom.xml
          else
            echo "Missing pom.xml in /tmp/artifacts; aborting"
            exit 1
          fi

      - name: Create signed git tag (GPG)
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
          GPG_KEYID: ${{ env.GPG_KEYID }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          # Configure git for tagging and authentication
          git config --global user.email "ci@risquanter.example"
          git config --global user.name "Release Bot"
          git config --global url."https://${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"

          # Construct a release tag using short SHA
          RELEASE_TAG="v${GITHUB_SHA:0:8}"

          # Create a GPG-signed tag non-interactively using the imported key
          git tag -s "$RELEASE_TAG" -m "Release $RELEASE_TAG" --local-user "$GPG_KEYID" --no-verify || true

          # Push the tag using authenticated git
          git push origin "$RELEASE_TAG"

      # Write settings.xml for Central Publisher Portal
      # Uses CENTRAL_PORTAL_USERNAME and CENTRAL_PORTAL_TOKEN for authentication
      # Paste the generated <server> block from the portal as shown below
      - name: Write settings.xml for Central Publisher Portal
        env:
          CENTRAL_PORTAL_USERNAME: ${{ secrets.CENTRAL_PORTAL_USERNAME }}
          CENTRAL_PORTAL_TOKEN: ${{ secrets.CENTRAL_PORTAL_TOKEN }}
        run: |
          mkdir -p "$HOME/.m2"
          cat > "$HOME/.m2/settings.xml" << EOF
          <settings>
            <servers>
              <server>
                <id>central</id>
                <username>${CENTRAL_PORTAL_USERNAME}</username>
                <password>${CENTRAL_PORTAL_TOKEN}</password>
              </server>
            </servers>
          </settings>
          EOF
          chmod 600 "$HOME/.m2/settings.xml"

      # Deploy to Maven Central Publisher Portal (derive GAV from POM, attach signatures and Sigstore bundles)
      # Uses new endpoint and token authentication for Central Publisher Portal
      - name: Deploy to Maven Central Publisher Portal (derive GAV from POM, attach signatures and Sigstore bundles)
        env:
          CENTRAL_PORTAL_TOKEN: ${{ secrets.CENTRAL_PORTAL_TOKEN }}
        run: |
          set -euo pipefail
          cd /tmp/artifacts

          MAIN_JAR=$(ls *.jar | grep -v -- "-sources.jar\|-javadoc.jar" | head -1)
          SOURCES_JAR=$(ls *-sources.jar | head -1)
          JAVADOC_JAR=$(ls *-javadoc.jar | head -1)

          if [ -z "$MAIN_JAR" ] || [ -z "$SOURCES_JAR" ] || [ -z "$JAVADOC_JAR" ]; then
            echo "Error: Missing required JAR files"
            exit 1
          fi

          # Derive GAV from pom.xml (xmlstarlet)
          NS="http://maven.apache.org/POM/4.0.0"
          GROUP_ID=$(xmlstarlet sel -N x="$NS" -t -v "string(/x:project/x:groupId)" pom.xml)
          if [ -z "$GROUP_ID" ]; then
            GROUP_ID=$(xmlstarlet sel -N x="$NS" -t -v "string(/x:project/x:parent/x:groupId)" pom.xml)
          fi
          ARTIFACT_ID=$(xmlstarlet sel -N x="$NS" -t -v "string(/x:project/x:artifactId)" pom.xml)
          VERSION=$(xmlstarlet sel -N x="$NS" -t -v "string(/x:project/x:version)" pom.xml)
          if [ -z "$VERSION" ]; then
            VERSION=$(xmlstarlet sel -N x="$NS" -t -v "string(/x:project/x:parent/x:version)" pom.xml)
          fi

          if [ -z "$GROUP_ID" ] || [ -z "$ARTIFACT_ID" ] || [ -z "$VERSION" ]; then
            echo "Failed to derive groupId/artifactId/version from pom.xml"
            exit 1
          fi

          echo "Derived coordinates: ${GROUP_ID}:${ARTIFACT_ID}:${VERSION}"
          FILES_LIST="${MAIN_JAR},${SOURCES_JAR},${JAVADOC_JAR},${MAIN_JAR}.asc,${SOURCES_JAR}.asc,${JAVADOC_JAR}.asc,pom.xml,pom.xml.asc"
          CLASSIFIERS_LIST=",sources,javadoc,asc,asc,asc,pom,asc"
          TYPES_LIST="jar,jar,jar,asc,asc,asc,pom,asc"

          # Attach any Sigstore provenance files if present (experimental)
          if ls *.bundle >/dev/null 2>&1; then
            for b in *.bundle; do
              FILES_LIST="${FILES_LIST},${b}"
              CLASSIFIERS_LIST="${CLASSIFIERS_LIST},sigstore"
              TYPES_LIST="${TYPES_LIST},sig"
            done
          fi
          if ls *.cert >/dev/null 2>&1; then
            for c in *.cert; do
              FILES_LIST="${FILES_LIST},${c}"
              CLASSIFIERS_LIST="${CLASSIFIERS_LIST},sigstore-cert"
              TYPES_LIST="${TYPES_LIST},cert"
            done
          fi
          if ls *.sig >/dev/null 2>&1; then
            for s in *.sig; do
              FILES_LIST="${FILES_LIST},${s}"
              CLASSIFIERS_LIST="${CLASSIFIERS_LIST},sigstore-sig"
              TYPES_LIST="${TYPES_LIST},sig"
            done
          fi

          echo "Files to deploy: ${FILES_LIST}"
          echo "Classifiers: ${CLASSIFIERS_LIST}"
          echo "Types: ${TYPES_LIST}"

          mvn -B org.apache.maven.plugins:maven-deploy-plugin:3.0.0-M1:deploy-file \
            -Durl="https://central.sonatype.org/publish/repository/maven" \
            -DrepositoryId=central \
            -Dfile="${MAIN_JAR}" -DpomFile="pom.xml" \
            -Dfiles="${FILES_LIST}" -Dclassifiers="${CLASSIFIERS_LIST}" -Dtypes="${TYPES_LIST}" \
            --settings "$HOME/.m2/settings.xml"

          echo "Deployment completed (staged)."
          echo "Open https://central.sonatype.com/ to inspect the created staging repository and close it manually."

      - name: Clean up (always)
        if: always()
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
        run: |
          set +e
          # remove ephemeral GNUPGHOME
          if [ -n "${GNUPGHOME:-}" ] && [ -d "${GNUPGHOME}" ]; then
            rm -rf "${GNUPGHOME}"
          fi
          # remove temporary maven settings
          if [ -f "$HOME/.m2/settings.xml" ]; then
            shred -u "$HOME/.m2/settings.xml" || rm -f "$HOME/.m2/settings.xml"
          fi
