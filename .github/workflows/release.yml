###############################################################
# This workflow is adapted for Maven Central Publisher Portal
# Migration from OSSRH: all endpoints, authentication, and deployment
# now use the Central Publisher Portal API and token-based auth.
#
# Required repository secrets:
#   - GPG_PRIVATE_KEY: ASCII-armored GPG private key for signing
#   - GPG_PASSPHRASE: Passphrase for the GPG key
#   - TOTP_SECRET: Base32 secret for TOTP verification
#   - CENTRAL_PORTAL_USERNAME: Username (special purpose) for Maven Central Publisher Portal
#   - CENTRAL_PORTAL_TOKEN: Token generated from Maven Central Publisher Portal
#
# For details, see:
#   https://central.sonatype.org/publish/publish-portal-maven/
#   https://central.sonatype.org/publish/generate-portal-token/
###############################################################

name: Release (Maven Central Publisher Portal, GPG-signed)

on:
  workflow_dispatch:
    inputs:
      run_id:
        description: 'Build run ID to release'
        required: true
      totp_code:
        description: 'TOTP code from your authenticator app'
        required: true

permissions:
  contents: write
  id-token: write

jobs:
  verify-authorization:
    runs-on: ubuntu-latest
    steps:
      - name: Install oathtool
        run: sudo apt-get update && sudo apt-get install --no-install-recommends -y oathtool

      - name: Verify TOTP
        env:
          TOTP_SECRET: ${{ secrets.TOTP_SECRET }}
          INPUT_TOTP: ${{ inputs.totp_code }}
        run: |
          set -euo pipefail
          date --utc
          EXPECTED=$(oathtool --totp --base32 --time-step-size 60 "$TOTP_SECRET")
          if [ "${INPUT_TOTP}" != "$EXPECTED" ]; then
            echo "❌ Invalid TOTP code"
            echo "Expected: $EXPECTED"
            exit 1
          fi
          echo "✅ TOTP verified successfully"


  # JOB 2: Signing and release (ubuntu-latest)
  sign-and-publish:
    needs: verify-authorization
    runs-on: ubuntu-latest
    environment: release
    permissions:
      contents: write
      id-token: write
      actions: read

    env:
      ARTIFACT_RUN_ID: ${{ inputs.run_id }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Install tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq tar gpg xmlstarlet

      - name: Download unsigned artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh run download ${{ inputs.run_id }} \
            --name unsigned-artifacts-${{ inputs.run_id }} \
            --dir /tmp/release-artifacts \
            --repo ${{ github.repository }}

      - name: Download provenance
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh run download ${{ inputs.run_id }} \
            --name provenance-${{ inputs.run_id }} \
            --dir /tmp/release-provenance \
            --repo ${{ github.repository }}

      - name: Extract and verify
        run: |
          mkdir -p /tmp/artifacts
          tar xzf /tmp/release-artifacts/artifacts.tgz -C /tmp/artifacts
          if [ -f /tmp/release-provenance/provenance.tgz ]; then
            tar xzf /tmp/release-provenance/provenance.tgz -C /tmp/artifacts || true
          fi
          cd /tmp/artifacts
          sha256sum -c checksums.sha256

    # - name: (Optional) Listing Sigstore provenance files
    #   run: |
    #     for s in /tmp/artifacts/*.bundle /tmp/artifacts/*.sigstore.json; do
    #       [ -f "$s" ] && echo "Found provenance: $s"
    #     done


    # No verification of Sigstore provenance is done here;
    # users can verify signatures after download.
    # Sigstore provenance is attached during deployment below.
      - name: (Optional) List Sigstore provenance files
        run: |
          shopt -s nullglob
          echo "Sigstore provenance files:"
          ls -lh /tmp/artifacts/*.bundle 2>/dev/null || echo "No .bundle files found"
          echo "Sigstore signature files:"
          ls -lh /tmp/artifacts/*.sig 2>/dev/null || echo "No .sig files found"
          echo "Sigstore certificate files:"
          ls -lh /tmp/artifacts/*.cert 2>/dev/null || echo "No .cert files found"

      - name: Import encrypted GPG private-subkey into ephemeral GNUPGHOME
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail

          # create ephemeral GNUPGHOME for isolation
          export GNUPGHOME="$(mktemp -d)"
          chmod 700 "$GNUPGHOME"

          # write the armored encrypted blob to a temp file (do not expose to logs)
          TMP_ENC="/tmp/private-subkey.asc.gpg"
          printf '%s' "$GPG_PRIVATE_KEY" > "$TMP_ENC"
          chmod 600 "$TMP_ENC"

          # decrypt the encrypted blob into a temporary plaintext file
          TMP_PLAINT="/tmp/private-subkey.asc"
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
            --decrypt --output "$TMP_PLAINT" "$TMP_ENC"

          # import the plaintext secret subkey into the ephemeral GNUPGHOME
          gpg --batch --import "$TMP_PLAINT"

          # kill agent to ensure allowed settings are applied later if needed
          gpgconf --kill gpg-agent || true

          # discover the signing keyid (first secret key)
          KEYID=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5; exit}')
          if [ -z "$KEYID" ]; then
            echo "Failed to determine GPG KEYID"
            shred -u "$TMP_PLAINT" || rm -f "$TMP_PLAINT"
            rm -f "$TMP_ENC"
            exit 1
          fi

          # export GNUPGHOME and KEYID for subsequent steps
          echo "GNUPGHOME=$GNUPGHOME" >> $GITHUB_ENV
          echo "GPG_KEYID=$KEYID" >> $GITHUB_ENV

          # store public key copy for inspection if needed
          gpg --armor --export "$KEYID" > "$GNUPGHOME/publickey.asc"

          # securely delete the plaintext file as soon as possible
          shred -u "$TMP_PLAINT" || rm -f "$TMP_PLAINT"
          rm -f "$TMP_ENC"

          echo "Imported encrypted GPG subkey into ephemeral GNUPGHOME and removed plaintext."




      # Write settings.xml for Central Publisher Portal
      # Uses CENTRAL_PORTAL_USERNAME and CENTRAL_PORTAL_TOKEN for authentication
      # Paste the generated <server> block from the portal as shown below
      - name: Write settings.xml for Central Publisher Portal
        env:
          CENTRAL_PORTAL_USERNAME: ${{ secrets.CENTRAL_PORTAL_USERNAME }}
          CENTRAL_PORTAL_TOKEN: ${{ secrets.CENTRAL_PORTAL_TOKEN }}
        run: |
          mkdir -p "$HOME/.m2"
          cat > "$HOME/.m2/settings.xml" << EOF
          <settings>
            <servers>
              <server>
                <id>central</id>
                <username>${CENTRAL_PORTAL_USERNAME}</username>
                <password>${CENTRAL_PORTAL_TOKEN}</password>
              </server>
            </servers>
          </settings>
          EOF
          chmod 600 "$HOME/.m2/settings.xml"

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      - name: Deploy to Maven Central Publisher Portal
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
          GPG_KEYID: ${{ env.GPG_KEYID }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail

          # Copy pre-built artifacts to target directory
          mkdir -p target
          cp /tmp/artifacts/*.jar target/
          cp /tmp/artifacts/pom.xml . || true
          cp /tmp/artifacts/*.bundle target/ || true
          cp /tmp/artifacts/*.sig target/ || true
          cp /tmp/artifacts/*.cert target/ || true

          # Find the main JAR (without -sources or -javadoc)
          MAIN_JAR=$(ls target/*.jar | grep -v '\-sources\|\-javadoc' | head -1)

          echo "Main JAR to install: $MAIN_JAR"

          # Install pre-built artifacts to local Maven repo
          mvn -B install:install-file -Dfile="$MAIN_JAR" \
            -DpomFile=pom.xml -Dpackaging=jar

          # Now deploy (will sign with GPG and upload to Central Portal)
          mvn -B deploy -Prelease -DskipTests -Dmaven.install.skip=true --settings "$HOME/.m2/settings.xml"

          echo "Deployment completed (staged)."
          echo "Open https://central.sonatype.com/ to inspect and publish the deployment."

      - name: Create signed git tag (GPG)
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
          GPG_KEYID: ${{ env.GPG_KEYID }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Configure git for tagging and authentication
          git config --global user.email "ci@risquanter.example"
          git config --global user.name "Release Bot"
          git config --global url."https://${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"

          # Pre-authenticate GPG agent by signing a dummy file
          # This caches the passphrase for subsequent git tag operation
          echo "test" | gpg --batch --yes --pinentry-mode loopback \
            --passphrase "${GPG_PASSPHRASE}" --local-user "${GPG_KEYID}" \
            --sign --armor > /dev/null 2>&1

          # Construct a release tag using short SHA
          git fetch --all --tags
          git checkout $GITHUB_SHA
          RELEASE_TAG="v${GITHUB_SHA:0:8}"

          # Create a GPG-signed tag (agent now has cached passphrase)
          git tag -s "$RELEASE_TAG" -m "Release $RELEASE_TAG" \
            --local-user "$GPG_KEYID" || true

          # Push the tag using authenticated git
          git push origin "$RELEASE_TAG"

      - name: Clean up (always)
        if: always()
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
        run: |
          set +e
          # remove ephemeral GNUPGHOME
          if [ -n "${GNUPGHOME:-}" ] && [ -d "${GNUPGHOME}" ]; then
            rm -rf "${GNUPGHOME}"
          fi
          # remove temporary maven settings
          if [ -f "$HOME/.m2/settings.xml" ]; then
            shred -u "$HOME/.m2/settings.xml" || rm -f "$HOME/.m2/settings.xml"
          fi
