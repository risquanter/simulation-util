###############################################################
# This workflow is adapted for Maven Central Publisher Portal
# Migration from OSSRH: all endpoints, authentication, and deployment
# now use the Central Publisher Portal API and token-based auth.
#
# Required repository secrets:
#   - GPG_PRIVATE_KEY: ASCII-armored GPG private key for signing
#   - GPG_PASSPHRASE: Passphrase for the GPG key
#   - TOTP_SECRET: Base32 secret for TOTP verification
#   - CENTRAL_PORTAL_USERNAME: Username (special purpose) for Maven Central Publisher Portal
#   - CENTRAL_PORTAL_TOKEN: Token generated from Maven Central Publisher Portal
#
# For details, see:
#   https://central.sonatype.org/publish/publish-portal-maven/
#   https://central.sonatype.org/publish/generate-portal-token/
###############################################################

name: Release (Maven Central Publisher Portal, GPG-signed)

on:
  workflow_dispatch:
    inputs:
      run_id:
        description: 'Build run ID to release'
        required: true
      totp_code:
        description: 'TOTP code from your authenticator app'
        required: true

permissions:
  contents: write
  id-token: write

jobs:
  verify-authorization:
    runs-on: ubuntu-latest
    steps:
      - name: Install oathtool
        run: sudo apt-get update && sudo apt-get install --no-install-recommends -y oathtool

      - name: Verify TOTP
        env:
          TOTP_SECRET: ${{ secrets.TOTP_SECRET }}
          INPUT_TOTP: ${{ inputs.totp_code }}
        run: |
          set -euo pipefail
          date --utc
          EXPECTED=$(oathtool --totp --base32 --time-step-size 60 "$TOTP_SECRET")
          if [ "${INPUT_TOTP}" != "$EXPECTED" ]; then
            echo "❌ Invalid TOTP code"
            echo "Expected: $EXPECTED"
            exit 1
          fi
          echo "✅ TOTP verified successfully"


  # JOB 2: Signing and release (ubuntu-latest)
  sign-and-publish:
    needs: verify-authorization
    runs-on: ubuntu-latest
    environment: release
    permissions:
      contents: write
      id-token: write
      actions: read

    env:
      ARTIFACT_RUN_ID: ${{ inputs.run_id }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Install tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq tar gpg xmlstarlet

      - name: Download unsigned artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh run download ${{ inputs.run_id }} \
            --name unsigned-artifacts-${{ inputs.run_id }} \
            --dir /tmp/release-artifacts \
            --repo ${{ github.repository }}

      - name: Download provenance
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh run download ${{ inputs.run_id }} \
            --name provenance-${{ inputs.run_id }} \
            --dir /tmp/release-provenance \
            --repo ${{ github.repository }}

      - name: Extract and verify
        run: |
          mkdir -p /tmp/artifacts
          tar xzf /tmp/release-artifacts/artifacts.tgz -C /tmp/artifacts
          if [ -f /tmp/release-provenance/provenance.tgz ]; then
            tar xzf /tmp/release-provenance/provenance.tgz -C /tmp/artifacts || true
          fi
          cd /tmp/artifacts
          sha256sum -c checksums.sha256

    # - name: (Optional) Listing Sigstore provenance files
    #   run: |
    #     for s in /tmp/artifacts/*.bundle /tmp/artifacts/*.sigstore.json; do
    #       [ -f "$s" ] && echo "Found provenance: $s"
    #     done


    # No verification of Sigstore provenance is done here;
    # users can verify signatures after download.
    # Sigstore provenance is attached during deployment below.
      - name: (Optional) List Sigstore provenance files
        run: |
          shopt -s nullglob
          echo "Sigstore provenance files:"
          ls -lh /tmp/artifacts/*.bundle 2>/dev/null || echo "No .bundle files found"
          echo "Sigstore signature files:"
          ls -lh /tmp/artifacts/*.sig 2>/dev/null || echo "No .sig files found"
          echo "Sigstore certificate files:"
          ls -lh /tmp/artifacts/*.cert 2>/dev/null || echo "No .cert files found"

      - name: Import encrypted GPG private-subkey into ephemeral GNUPGHOME
        env:
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          set -euo pipefail

          # create ephemeral GNUPGHOME for isolation
          export GNUPGHOME="$(mktemp -d)"
          chmod 700 "$GNUPGHOME"

          # write the armored encrypted blob to a temp file (do not expose to logs)
          TMP_ENC="/tmp/private-subkey.asc.gpg"
          printf '%s' "$GPG_PRIVATE_KEY" > "$TMP_ENC"
          chmod 600 "$TMP_ENC"

          # decrypt the encrypted blob into a temporary plaintext file
          TMP_PLAINT="/tmp/private-subkey.asc"
          gpg --batch --yes --pinentry-mode loopback --passphrase "$GPG_PASSPHRASE" \
            --decrypt --output "$TMP_PLAINT" "$TMP_ENC"

          # import the plaintext secret subkey into the ephemeral GNUPGHOME
          gpg --batch --import "$TMP_PLAINT"

          # kill agent to ensure allowed settings are applied later if needed
          gpgconf --kill gpg-agent || true

          # discover the signing keyid (first secret key)
          KEYID=$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5; exit}')
          if [ -z "$KEYID" ]; then
            echo "Failed to determine GPG KEYID"
            shred -u "$TMP_PLAINT" || rm -f "$TMP_PLAINT"
            rm -f "$TMP_ENC"
            exit 1
          fi

          # export GNUPGHOME and KEYID for subsequent steps
          echo "GNUPGHOME=$GNUPGHOME" >> $GITHUB_ENV
          echo "GPG_KEYID=$KEYID" >> $GITHUB_ENV

          # store public key copy for inspection if needed
          gpg --armor --export "$KEYID" > "$GNUPGHOME/publickey.asc"

          # securely delete the plaintext file as soon as possible
          shred -u "$TMP_PLAINT" || rm -f "$TMP_PLAINT"
          rm -f "$TMP_ENC"

          echo "Imported encrypted GPG subkey into ephemeral GNUPGHOME and removed plaintext."




      # Write settings.xml for Central Publisher Portal
      # Uses CENTRAL_PORTAL_USERNAME and CENTRAL_PORTAL_TOKEN for authentication
      # Paste the generated <server> block from the portal as shown below
      - name: Write settings.xml for Central Publisher Portal
        env:
          CENTRAL_PORTAL_USERNAME: ${{ secrets.CENTRAL_PORTAL_USERNAME }}
          CENTRAL_PORTAL_TOKEN: ${{ secrets.CENTRAL_PORTAL_TOKEN }}
        run: |
          mkdir -p "$HOME/.m2"
          cat > "$HOME/.m2/settings.xml" << 'EOF'
          <settings>
            <servers>
              <server>
                <id>central</id>
                <username>USERNAME_PLACEHOLDER</username>
                <password>PASSWORD_PLACEHOLDER</password>
              </server>
            </servers>
          </settings>
          EOF

          # Replace placeholders with actual values
          sed -i "s/USERNAME_PLACEHOLDER/${CENTRAL_PORTAL_USERNAME}/g" "$HOME/.m2/settings.xml"
          sed -i "s/PASSWORD_PLACEHOLDER/${CENTRAL_PORTAL_TOKEN}/g" "$HOME/.m2/settings.xml"
          chmod 600 "$HOME/.m2/settings.xml"

          # Verify
          echo "======================================"
          echo "Settings.xml verification:"
          echo "======================================"
          if [ -f "$HOME/.m2/settings.xml" ]; then
            echo "✅ settings.xml exists at: $HOME/.m2/settings.xml"
            echo "File size: $(stat -c%s "$HOME/.m2/settings.xml")"
            echo "Server ID check:"
            grep -q '<id>central</id>' "$HOME/.m2/settings.xml" && echo "✅ Server 'central' configured" || echo "❌ Server 'central' NOT found"
          else
            echo "❌ ERROR: settings.xml was not created!"
            exit 1
          fi
          echo "======================================"

      - name: Debug Maven settings
        run: |
          echo "======================================"
          echo "Maven settings debug:"
          echo "======================================"
          echo "HOME: $HOME"
          echo "Contents of $HOME/.m2/settings.xml:"
          cat "$HOME/.m2/settings.xml"
          echo ""
          echo "Running mvn help:effective-settings to see what Maven sees:"
          mvn help:effective-settings -s "$HOME/.m2/settings.xml"

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'


      - name: Deploy to Maven Central Publisher Portal
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
          GPG_KEYID: ${{ env.GPG_KEYID }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          CENTRAL_PORTAL_USERNAME: ${{ secrets.CENTRAL_PORTAL_USERNAME }}
          CENTRAL_PORTAL_TOKEN: ${{ secrets.CENTRAL_PORTAL_TOKEN }}
        run: |
          set -euo pipefail

          # Configure GPG agent for Maven's GPG plugin
          cat > "$GNUPGHOME/gpg-agent.conf" << EOF
          allow-loopback-pinentry
          max-cache-ttl 7200
          default-cache-ttl 7200
          EOF

          cat > "$GNUPGHOME/gpg.conf" << EOF
          use-agent
          pinentry-mode loopback
          EOF

          # Restart GPG agent with new config
          gpgconf --kill gpg-agent || true
          gpg-agent --daemon --allow-loopback-pinentry || true

          echo "Running clean Maven package (build + sign, but don't deploy yet)..."

          # Build and sign artifacts WITHOUT deploying
          mvn -B -ntp clean verify -DskipTests \
            -Dgpg.passphrase="${GPG_PASSPHRASE}"

          # Check for required artifacts in target/
          echo "Checking for required artifacts in target/..."
          cd target
          REQUIRED_FILES=(
            "simulation.util-*.jar"
            "simulation.util-*-sources.jar"
            "simulation.util-*-javadoc.jar"
            "pom.xml.asc"
            "simulation.util-*.jar.asc"
            "simulation.util-*-sources.jar.asc"
            "simulation.util-*-javadoc.jar.asc"
          )
          for pattern in "${REQUIRED_FILES[@]}"; do
            if ! ls $pattern >/dev/null 2>&1; then
              echo "❌ Missing required artifact: $pattern"
              exit 1
            else
              echo "✅ Found: $pattern"
            fi
          done
          cd ..

          echo "Now explicitly running central-publishing:publish..."

          # Upload to Central Portal
          mvn -B -ntp central-publishing:publish \
            --settings "$HOME/.m2/settings.xml" \
            -Dgpg.passphrase="${GPG_PASSPHRASE}" \
            -DpublishingServerId=central

          # Note: The publish goal stages the deployment
          # You must manually publish from https://central.sonatype.com/

          echo "Deployment completed (staged)."
          echo "Open https://central.sonatype.com/ to inspect and publish the deployment."

      - name: Create signed git tag (GPG)
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
          GPG_KEYID: ${{ env.GPG_KEYID }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Configure git for tagging and authentication
          git config --global user.email "ci@risquanter.example"
          git config --global user.name "Release Bot"
          git config --global url."https://${GITHUB_TOKEN}@github.com/".insteadOf "https://github.com/"

          # Pre-authenticate GPG agent by signing a dummy file
          # This caches the passphrase for subsequent git tag operation
          echo "test" | gpg --batch --yes --pinentry-mode loopback \
            --passphrase "${GPG_PASSPHRASE}" --local-user "${GPG_KEYID}" \
            --sign --armor > /dev/null 2>&1

          # Construct a release tag using short SHA
          git fetch --all --tags
          git checkout $GITHUB_SHA
          RELEASE_TAG="v${GITHUB_SHA:0:8}"

          # Create a GPG-signed tag (agent now has cached passphrase)
          git tag -s "$RELEASE_TAG" -m "Release $RELEASE_TAG" \
            --local-user "$GPG_KEYID" || true

          # Push the tag using authenticated git
          git push origin "$RELEASE_TAG"

      - name: Clean up (always)
        if: always()
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
        run: |
          set +e
          # remove ephemeral GNUPGHOME
          if [ -n "${GNUPGHOME:-}" ] && [ -d "${GNUPGHOME}" ]; then
            rm -rf "${GNUPGHOME}"
          fi
          # remove temporary maven settings
          if [ -f "$HOME/.m2/settings.xml" ]; then
            shred -u "$HOME/.m2/settings.xml" || rm -f "$HOME/.m2/settings.xml"
          fi
